

# 동기식 렌더링의 문제

간단히 말해 동기식 렌더링의 문제는 메인 스레드를 가로막아서 사용자 경험이 저하된다는 점이다. 

이러한 문제를 해결하기 위해서 널리 사용되는 방법은 여러 업데이트를 일괄 처리해서 메인 스레드에서 수행되는 작업을 최소화 하는 것이다. 
예를 들어 작업이 10개 있으면 각각 실행해 총 10번을 실행하기 보다는 한번에 묶어서 처리하는 것이다. 

하지만 일괄처리에도 한계가 존재한다. 

동기식 렌더링에는 우선순위 개념이 존재하지 않는다. 그래서 일괄처리를 사용해 봤자 한계가 있다. (화면에 보이지 않는 작업도 같은 우선순위로 되어 있다.)

사용자가 볼 수 있고 상호 작용할 수 있는 항목이 우선적으로 먼저 렌더링 되어야 한다. 

이러한 문제들을 리액트는 동시성 렌더링을 사용해 업데이트 작업의 중요도와 긴급도에 따라 우선순위를 정한다. 
하지만 동시성 렌더링은 CPU를 많이 소모하는 렌더링 작업은 덜 중요한 작업으로 간주되고, 사용자 상호 작용이나 애니메이션 같은 더 중요한 작업이 우선적으로 처리된다. 

또한, 렌더링 프로세스를 더 작은 덩어리로 분할해 점진적으로 처리하는 기법도 가능하다. 

# 파이버 다시보기
파이버 재조정자는 동시성 렌더링을 가능케 하는 리액트의 핵심 메커니즘입니다. 스택 재조정자에 비해 아키텍처 측면이 크게 변화하였다. 

파이버 재조정자는 렌더링 프로세스를 파이버라고 하는 더 작고 관리하기 쉬운 작업 단위로 분할래 처리한다. 

# 업데이트 예약과 지연

리액트에서 업데이트를 예약하고 지연하는 기능은 애플리케이션의 응답성을 유지하는 데 매우 중요하다. 파이버 재조정자는 스케줄러와 여러 효율적인 API에 의존해 구현한다. 이러한 API를 통해 리액트는 유휴 시간 동안 작업을 수행하고, 적절한 시기에 업데이트를 예약할 수 있다. 

스케줄러는 브라우저 API를 사용해서 '이 작업은 지금 처리하고, 이 작업은 나중에 처리해' 하는 식으로 작업을 예약, 관리하는 시스템이다. 

메세지 어플에서는 사용자가 메시지를 입력하거나 전송할 때, 텍스트 입력 업데이트를 다른 업데이트보다 우선적으로 처리한다. 
또한, 리액트는 렌더 레인을 통해 렌더링하는데 이 레인은 동기식으로 DOM을 업데이트 한다. 업데이트를 가로막게 되므로 사용자 입력에 지연이 발생한다. 새 메시지 목록을 렌더링하는 작업의 우선순위를 낮추려면, 관련 상태 업데이트를 useTransition hook의 startTransition함수 감싸서 사용한다. 

# 더 깊이 들어가기

### 스케줄러

리액트 아키텍처의 핵심인 스케줄러는 타이밍 관련 유틸리티를 제공하는 독립형 패키지로, 파이버 재조정와는 별개로 동작한다. 
리액트는 재조정자 내에서 이 스케줄러를 사용한다. 스케줄러와 재조정자는 렌더 레인을 통해 작업의 긴급도에 따라 우선순위를 설정하고 정리해 여러 작업이 협력하도록 한다. 
스케줄러의 주된 기능은 마이크로테스크를 예약해서 메인 스레드의 제어를 관리하고 원할한 실행을 보장한다. 

리액트 코드베이스의 ensureRootIsScheduled 함수는 렌더링 프로세스를 관리하는 데 중요하다. 이 함수는 root: FiberRoot로 표시되는 리액트 루트가 업데이트 되면 호충되어 두가지 중요한 작업을 수행한다. 

호출된 ensureRootIsScheduled 함수는 루트 스케줄에 루트가 포함되었는지 확인한다. 
마이크로태스크는 자바스크립트 이벤트 루프 관리에서 중요한 개념으로, 마이크로태스크 큐에 의해 관리되는 작업의 일종이다. 정리하자면 ensureRootIsScheduled는 리액트의 작업 예약과 렌더링 로직의 여러 측면을 통합한 복잡한 함수로, 리액트 루트에 대한 업데이트를 효율적으로 관리하고 작업과 마이크로태스크를 전략적으로 예약해서 원활한 렌더링을 보장하는 데 중점을 둔다. -> 렌더 렌인이 업데이트의 우선순위를 나타낸다. 


# 렌더 레인

렌더 레인은 리액트의 예약 시스템에서 중요한 요소이다. 작업의 렌더링과 우선순위 관리를 효율적으로 한다. 

setState가 그냥 호출되면 마이크로테스로 예약, startTransition의 트랜지션내에서 호출되면 우선순위가 낮아진다. 

1. **SyncHydrationLane**  - 하이드레이션 도중 사용자가 리액트 앱을 클릭하면 클릭 이벤트가 이 레인으로 들어간다. 
2. **SyncLane** - 사용가 리액트 앱을 클릭하면 클릭 이벤트가 이 레인으로 들어간다. 
3. **InputContinuousHydrationLane** - 하이드레이션 도중 발생하는 호버, 스크롤을 비롯한 연속적인 이벤트를 다룬다는 점이 다르다. 
4. **InputContinuousLane** - 바로 앞에서 설명한 레인과 동일하지만, 하이드레이션 이후의 이벤트를 다룬다는 점이 다릅니다. 
5. **DefaultLane** - 모든 네트워크 업데이트, setTimeout 같은 타이머, 우선순위가 파악되지 않는 초기 렌더링이 이 레인으로 들어갑니다. 
6. **TransitionHydrationLane** - 하이드레이션 도중 startTransition에서 발생하는 모든 트렌지션이 이 레인에 배치됩니다. 
7. **TransitionLanes(1-15)** - 하이드레이션 gn startTransition에서 발생하는 모든 트렌지션이 이 레인에 배치됩니다. 
8. **RetryLanes(1-4)** - Suspense에서 발생하는 모든 재시도가 이 레인에 배치됩니다. 

### 렌더 레인 작동 방식

컴포넌트가 업데이트 되거나 새 컴포넌트가 렌더 트리에 추가 되었을 때 위 우선쉬위에 따라 레인을 할당한다. 우선순위는 컴포넌트의 가시성에 따라 달라진다. 

렌더 레인을 사용한 업데이트 예약 및 우선순위

1. 업데이트 수집 - 마지막 렌더링 이후에 예약된 모든 업데이트를 수집해서 우선순위에 따라 각 레인에 할당
2. 레인 처리 - 우선순위가 가장 높은 레인부터 시작해 각 레인에 있는 업데이트를 처리한다. 같은 레인의 업데이트는 한꺼번에 일괄 처리한다. 
3. 커밋 단계 - 모든 업데이트를 처리한 후, 커밋 단계로 진입해 변경 사항을 DOM에 적용하고, 효과를 실행하고, 기타 마무리 작업을 수행한다. 
4. 반복 - 렌더링을 할 때마다 업데이트가 항상 우선순위대로 처리되도록 보장하고, 우선순위가 높은 업데이트가 우선순위가 낮은 업데이트에 의해 가로 막히지 않도록 한다. 

업데이트가 발생하면 리액트는 우선순위를 결정하고 적절한 레인에 할당한다. 

레인 처리 후 커밋 단계에서 DOM에 적용하고 부작용을 실행한다. 얽힘, 리베이스 등 복잡한 작업도 실행한다. 

useTransition, useDeferredValue같은 api에 따라 우선순위를 재정의 할 수 있다. 


