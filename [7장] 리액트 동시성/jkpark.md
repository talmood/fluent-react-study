### 동기식 렌더링의 문제

- 메인 스레드를 blocking하여 UX 저하
- 동기식 렌더링은 우선순위의 개념이 없음
- 동시성 렌더링을 사용해 업데이트 작업의 중요도/긴급도에 따라 우선순위를 결정
- 동시성 렌더링 기능 덕에 타임 슬라이싱 기법 사용
    - 타임 슬라이싱
        - 렌더링 프로세스를 작은 덩어리로 분할해 점진적으로 처리하는 기법
        - 여러 프레임에 걸쳐 작업을 수행하며 작업을 중지해야할 때 중지할 수 있게 됨

### 파이버

- 파이버 재조정자는 렌더링 프로세스를 파이버라는 작고 관리하기 쉬운 작업으로 분할하여 처리
- 파이버를 활용하여 렌더링 작업을 일시 중지, 재개. 우선순위를 결정하여 중요도에 따라 업데이트를 지연하거나 예약
- 애플리케이션의 응답성이 향상되고 덜 중요한 작업이 더 중요한 업데이트를 가로막는 일을 방지

### 업데이트 예약 및 지연

- 스케줄러
    - 해야할 업데이트 작업이 있을 때 `setTimeout.messageChannel` 등의 브라우저 API를 사용해 작업을 예약, 관리하는 시스템
    - 마이크로태스크를 예약해서 메인 스레드의 제어를 관리, 원활한 실행을 보장
    - `ensureRootIsScheduled`
        1. 루트가 스케줄에 포함되도록 보장, **루트 스케줄에 루트가 포함되었는지** 확인
        2. 루트 스케줄을 처리할 수 있도록 대기 중인 **마이크로태스크가 존재하는지** 확인
        - 실제 예약 로직 대부분은 `scheduleTaskForRootDuringMicrotask` 함수가 실행될 때 수행
        - 이벤트 루프
            - 매크로태스크 큐
                - 이벤트 처리, `setTimeout`, `setInterval` 콜백 실행, 입출력 작업
            - 마이크로태스크 큐
                - `Promise`, `MutationObserver`, `Object.observe` 등
            - 실행 순서
                1. 마이크로태스크는 JS 엔진이 작업 대기열에서 다음 매크로태스크를 선택하기 전에 처리
                2. 작업 실행 후 엔진은 마이크로태스크 대기열에 마이크로태스크가 있는지 확인
                3. 확인된 마이크로태스크를 모두 실행한 뒤 매크로태스크 실행
                4. 현재 실행 중인 스크립트가 완료된 직후, 렌더링이나 이벤트 처리 같은 다른 작업을 처리하기 전에, 마이크로태스크가 대기열에 쌓인 순서대로 빠르게 처리됨.
            - 특성
                - 마이크로태스크는 작업 대기열의 다른 작업보다 우선순위가 높음 → 마이크로태스크가 계속해서 마이크로태스크를 대기열에 추가하면 작업 대기열이 처리되지 않는 현상을 **기아 상태(starvation)**라고 함
        - `ensureRootIsScheduled`와 마이크로태스크의 관계
            - 리액트 내에서 UI 업데이트를 매끄럽게 유지, 작업을 효율적으로 관리하게 함
        - `mightHavePendingSyncWork` 플래그로 대기 중인 동기 작업이 있을 가능성을 나타냄
        - `enableDeferRootSchedulingToMicrotask` 플래그가 비활성화 되면 마이크로태스크 작업을 지연하지 않고 즉시 렌더링 작업을 예약. → 현재 해당 플래그 제거되어서 찾아보니
            - https://github.com/facebook/react/commit/379089d28875f565a488ec169e84c78e87a1dc4d#diff-b3d2d7db3b8f8517d9b1868d74049fadd238467c0a85f7f28d81a85db1f587daL143-R343
            - **자동 배칭 시스템**: 이전 플래그의 주요 목적이었던 배칭 기능이 `createRoot` API를 통해 기본적으로 모든 업데이트에 적용됩니다.
            - **scheduleUpdateOnFiber**: 이 내부 함수가 개선되어 업데이트를 스케줄링할 때 마이크로태스크 큐를 더 효율적으로 활용합니다.
            - **scheduleMicrotask**: React 18에서는 내부적으로 `queueMicrotask` 또는 `Promise.resolve().then()`을 활용하는 `scheduleMicrotask` 유틸리티를 일관되게 사용합니다.
        - 위처럼 개선되었다고 함. by Claude

### 렌더 레인

- 렌더링 과정에서 필요한 업데이트를 구성하고 우선순위를 설정하는 데 사용하는 가벼운 추상화

### 렌더 레인 작동 방식

1. 업데이트 수집
    - 마지막 렌더링 이후 예약된 모든 업데이트를 수집하여 우선순위에 따라 레인에 할당
2. 레인 처리
    - 우선순위 순으로 레인에 있는 업데이트 처리. **같은 레인의 업데이트는 한번에 처리**
3. 커밋 단계
    - 모든 업데이트 처리 후, DOM에 적용, 효과 실행, 마무리 작업 수행
4. 반복
    - 렌더링할때마다 업데이트의 우선순위를 보장
- 우선 순위 결정 방식
    1. 업데이트의 콘텍스트 확인
        - 업데이트 발생 콘텍스트 평가. 콘텍스트는 사용자 상호 작용, 상태/프롭 변경으로 인한 내부 업데이트, 서버 응답에 의한 업데이트 등일 수 있음.
    2. 콘텍스트에 따라 우선순위 추정
    3. 우선순위 재정의가 있는지 확인
        - `useTransition` , `useDeferredValue` 훅을 사용해 업데이트 우선순위를 명시적으로 설정할 수 있는데, 이 경우 추정한 우선순위 대신 명시적으로 설정된 우선순위를 사용
    4. 올바른 레인에 업데이트 할당
        - 비트마스크를 통해 이루어지고, 레인을 그룹화/처리
