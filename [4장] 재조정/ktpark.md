## 재조정

React.DOM.createRoot(element).render()의 동작 중점
### 재조정 이해하기
React.createElement 또는 JSX의 < 기호를 사용해 생성된다. 
꼭 필요한 최소한의 DOM API만 호출해 브라우저에 반영한다. 

### 일괄 처리
문서 조각은 다수의 DOM 노드를 포함하는 가벼운 컨테이너로, 일종의 임시 스테이징 영역처럼 동작해서 문서의 실제 DOM에 영향을 주지 않고 여러 변경 사항을 반영합니다. 

최종적으로 문서 조각을 DOM에 추가하면 단 한번의 리플로와 리페인팅이 발생한다. 

-> 리액트는 재조정 과정에서 여러 가상 DOM 업데이트를 모아 한 번의 DOM 업데이트로 결합한 후 실제 DOM에 일괄 업데이트 한다. 

(count + 1을 세 번 한다면 count + 3으로 한번에 처리)

일괄 처리는 앞으로 재조정의 일부이며, 재조정은 다음 DOM 상태와 현재 DOM을 일치시키는 과정

### 기존 기술
기존 react는 스택을 이용하였습니다. 스택 재조정다는 간단한 경우에는 잘 처리하였지만 복잡한 경우에는 여러 가지 문제가 발생한다. 문제는 아래와 같다.

1. 계산 비용이 비싼 컴포넌트가 렌더링을 막아 버리면 사용자 입력이 눈에 띄게 버벅이며 화면에 표시
2. 업데이트를 중단하거나 취소할 수 없다는 점

사용자 입력의 우선순위를 높게 설정해 입력 내용을 화면에 바로 반영하고 계산 비용이 큰 컴포넌트를 뒤늦게 렌더링 할 수 있다면, 사용자 경험 증가 한다. 이렇게 하기 위해서는 리액트가 특정 종류의 렌더링 연산을 다른 종류의 렌더링 보다 우선시해야 합니다. 

하지만 스택 재조정자는 업데이트의 우선순위를 정하지 않는다. 

이로인해 파이버 트리라는 데이터 구조를 기반으로 하는 기술이 등장하였다. 


### 파이버 재조정자
파이버는 데이터 구조를 사용하며 리액트 엘리먼트와 차이점은 파이버는 상태를 저장하고 수명이 긴 반면, 리액트 엘리먼트는 임시적이고 상태가 없다는 점이다. 

파이버는 특정 시점에 존재하며 실제 컴포넌트 트리를 나타내는 리액트 내부 데이터 구조다. 또한 우선순위를 정하고 이에 따라 동시 실행을 가능케 해서 리액트 애플리케이션의 성능과 응답성을 향상 시킨다. 


#### 데이터 구조로서의 파이버
파이버 재조정자는 업데이트의 우선순위를 정한다. 이에 따라 동시 실행을 가능케 해서 성능과 응답성을 향상 시킨다. 
본질적으로는 컴포넌트 인스턴스와 그 상태를 표현한다. (프롭, 상태, 하위 컴포넌트 등) 뿐만 아니라 컴포넌트 트리에서의 위치 정보, 파이버 재조정자가 업데이트 우선순위를 정하고 실행 하는 데 사용하는 메타 데이터도 포한된다. 
- tag : 컴포넌트를 식별
- type : 함수 or 클래스 식별
- props : 프롭 or 입력 인수
- stateNode : App 컴포넌트의 인스턴스. -> 이를 사용해 트리를 순회합니다. 

가상 DOM의 각 리액트 엘리먼트에 대해 파이버 노드를 생성 하는데 이 작업은 createFiberFromTypeAndProps 함수가 수행 -> 이 함수에서 말하는 '타입과 프롭'은 리액트 엘리먼트라고 부른다. 
파이버 노드가 생성되면 파이버 재조정자는 작업 루프를 사용해 사용자 인터페이스를 업데이트 합니다. (업데이트 가 필요한 경우 '더티'로 표시)
끝에 도달하면 다시 반대로 순회 하면서 브라우저의 DOM 트리와는 분리된 새 DOM 트리를 메모리에 생성한다. 새 DOM 트리는 이후 화면에 반영하는데 이를 flushed라고 한다. 
이 작업은 두가지 함수로 표현할 수 있는데
1. beginWork - 위에서 아래로 이동하며 컴포넌트를 '더티' 표시
2. completeWork - 다시 위로 이동하며 브라우저에서 분리된 실제 DOM 엘리먼트의 트리를 메모리에 구성
이러한 작업은 사용자가 볼 수 없으므로 언제든지 중단하고 버릴 수 있다. 

#### 더블 버퍼링
더블 버퍼링은 깜박임을 줄이고 체감 성능을 개선하는 기술이다. 
이미지나 프레임을 저장하기 위한 두 개의 버퍼 (or 메모리 공간 를 생성 하고 일정한 간격으로 두 버퍼를 전환해 최종으로 표시한다. 

실제 작동 방식 (번갈아 가며 빠르게 표시)
1. 첫 번째 버퍼가 초기 이미지나 프레임으로 채워집니다. 
2. 첫 번째 버퍼가 표시되는 동안 두 번째 버퍼가 새 데이터나 이미지로 업데이트됩니다. 
3. 두 번째 버퍼가 준비되면 첫 번째 버퍼로 전환되어 화면에 표시 됩니다.
4. 첫 번째와 두 번째 버퍼가 일정한 간격으로 최종 이미지나 동영상을 표시하는 프로세스가 계속 됩니다. 

더블 버퍼링 사용 시 중단이나 지연 없이 제공 가능

이는, 파이버가 사용하는 방식과 비슷 ( 인터페이스의 새로운 상태를 반영하도록 업데이트를 하는것을 렌더링이라고 한다. )

#### 파이버 재조정
파이버 재조정은 렌더링 단계, 커밋 단계로 이루어져 있다. 두 가지 단계이기 때문에 렌더링 중단이 가능하다. 

##### 렌더링 단계
렌더링 단계는 현재 트리에서 상태 변경 이벤트가 발생하면 시작한다. 각 파이버를 재귀적, 단계적으로 순회하고 업데이트가 보류 중이라는 신호 플래그를 설정해 대체 트리에 오프스크린 변경 작업을 수행한다. -> (내부적으로 beginWork 함수 발생)

##### beginWork(작업 시작)
아래로 내려가면서 더티를 표시한다. 계속 동일한 작업을 수행하며 작업이 완료되면 completeWork 실행 (이 작업에서 renderLanes를 이용해 우선순위를 정한다.)

#### completetWork(작업완료)
작업용 파이버 노드에 업데이트를 적용하고 실제 DOM 트리를 새롭게 생성한다. 호스트 환경이 브라우저라면 document.createElement, newElement.appendChild 같은 작업을 수행한다. 화면 밖에서 수행하면 중단할 수 있다. (우선순위가 높은 업데이트가 예약되면 만들어진 UI는 버려질 수 있다.)

complenteWork가 새 DOM 트리를 구성하면 '렌더링 단계가 완료되었다'로 볼  수 있다. 

##### 커밋 단계
렌더링 단계에서 가상 DOM에 적용된 변경 사항을 실제 DOM에 반영한다. 새 가상 DOM 트리가 호스트 환경에 커밋되고 작업용 트리가 현재 트리로 바뀐다. 
커밋 단계는 변형 단계, 레이아웃 단계로 나뉜다. 

- 변형 단계 : 가상 DOM에 적용된 변경 사항을 실제 DOM에 반영 (commitMutationEffects라는 특수 함수를 호출한다. )
- 레이아웃 단계 : DOM에서 업데이트 된 노드의 새 레이아웃을 계산한다.  (commitLayoutEffects라는 특수 함수를 호출한다. -> 이 함수는 DOM에서 업데이트 된 노드의 새 레이아웃을 계산한다. )


#### 효과
리액트 재조정 과정의 커밋 단계에서는 여러 부작용이 특정 순서로 실행
커밋 단계에서 발생하는 효과는 다음과 같다. 

- 배치 효과 : 새 컴포넌트가 DOM에 추가될 때 발생. 
- 업데이트 효과 : 컴포넌트가 새로운 프롭이나 상태로 업데이트될 때 발생
- 삭제 효과 : 컴포넌트가 DOM에서 제거될 때 발생
- 레이아웃 효과 : 브라우저 페이트 가능 시점 전에 발생

패시브 효과도 있는데 이는 브라우저 페인트 가능 시점 후에 실행(useEffect 훅 사용) -> API에서 데이터 요청이나 분석 추적처럼 페이지의 초기 렌더링에 중요하지 않은 작업을 수행하는데 유용


##### 화면에 모두 표시하기
리액트는 현재 트리나 작업용 트리 중 하나 위에 FiberRootNode를 둔다. 이는 재조정 과정의 커밋 단계를 관리하는 핵심 데이터 구조다. 
가상 DOM이 업데이트되면 리액트는 현재 트리를 변경하지 않은 채 작업용 트리를 업데이트 한다. 이를 통해 애플리케이션의 현재 상태를 유지하면서 가상 DOM을 계속 렌더링하고 업데이트 한다.  렌더링 프로세스가 완료되면 commitRoot 함수를 호출해 작업용 트리에 적용된 변경 사항을 실제 DOM에 커밋한다. 
commitRoot는 FiberRootNode의 포인터를 작업용 트리로 전환
이 이후부터는 새로운 트리를 기반으로 이루어지고 정확하고 효율적으로 적용할 수 있다. 
